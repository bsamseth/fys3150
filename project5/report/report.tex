\documentclass[11pt, twocolumn]{article}
\usepackage{../../latex/preamble}

\newcommand{\abs}[1]{|#1|}
\begin{document}
  % make title page
\begin{titlepage}
  \newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
  \center
  \textsc{\LARGE Universitetet i Oslo}\\[1.5cm] % Name of your university/college
  \textsc{\Large }\\[0.5cm] % Major heading such as course name
  \textsc{\large FYS3150}\\[0.5cm] % Minor heading such as course title
  \HRule \\[0.4cm]
  { \huge \bfseries N-body simulering}\\[0.4cm]
  \HRule \\[1.5cm]
  \Large \emph{Skrevet av:}\\
  Lyder \textsc{Rumohr Blingsmo} (k.nr. 2) og Bendik \textsc{Samseth} (k.nr. 27)\\[3cm]
  {\large \today}\\[3cm]
  \vfill
\end{titlepage}
\twocolumn[
\begin{@twocolumnfalse}
\tableofcontents
\vspace{\baselineskip}
\begin{abstract}
I denne rapporten utvikler vi en N-body modell. Det vil si et system av
$N$ masser som vekselvirker kun ved gravitasjon. Spesielt studerer vi kollaps
av et slik system når alle partiklene begynner i ro. Vi sammenligner 
stabiliteten til to forskjellige løsningsmetoder, RungeKutta4 og VelocityVerlet,
ved å kikke på energibevaring i systemet. 
Alt materiale som har blitt referert er tilgjengelig
 på Github~\cite{github-repo}. 

\end{abstract}
\vspace{\baselineskip}
\end{@twocolumnfalse}
]

\section{Innledning}
Vi ser på en åpen galaksehop med $N$ partikler. I vårt system antar vi at 
gravitasjon er den eneste kraften som virker

\begin{align}
 F = -\frac{GM_1M_2}{r^2}.\
\end{align}

Her er $G$ gravitasjonskonstanten, $M$ er massene og $r$ er avstanden mellom dem. 
Denne antagelsen er god under forutsetningen av $r$ er relativt stor. Vi bruker
Newtons andre lov, og får differensialligningene 

\begin{align} \label{eq:a_i}
a_i = \sum_{j \neq i} \frac{GM_j}{{|\vec{r_i} - \vec{r_j}|}^2} ,  i = 1,2, \cdots N 
\end{align}

Der $a_i$ er akselerasjonen til masse $i$. Dette er en ordinære differensialligning, og
vi anvender RungeKutta4 og Velocity-Verlet.

\subsection{Kort om RungeKutta4~\small{\cite{RK4}}}
Gitt en funksjon på formen 
\begin{align*}
\dot{y} = f(t, y), \quad y(t_0) = y_0
\end{align*}

I vårt tilfelle \eqref{eq:a_i} med 

\begin{align*}
\dot{v_i} = a_i 
\end{align*}
med initialbetingelsene
\begin{align*}
r_i(t_0) = r_{i,0},\ \  v_i(t_0) = 0
\end{align*}
Velg en steglengde $h>0$ og definer 

\begin{align*}
y_{n+1} &= y_n + \tfrac{h}{6}\left(k_1 + 2k_2 + 2k_3 + k_4 \right)\\
t_{n+1} &= t_n + h \\
\end{align*}
der vi har
\begin{align*}
k_1 &= f(t_n, y_n), \\
k_2 &= f(t_n + \tfrac{h}{2}, y_n + \tfrac{h}{2} k_1), \\
k_3 &= f(t_n + \tfrac{h}{2}, y_n + \tfrac{h}{2} k_2), \\
k_4 &= f(t_n + h, y_n + hk_3).
\end{align*}

Vi gjentar så metoden en gang til for 

\begin{align*}
\dot{x_i} = v_i
\end{align*}

\subsection{Kort Velocity-Verlet~\small{\cite{Velocity-Verlet}}}
Vi anvender også Velocity-Verlet på \eqref{eq:a_i}. Den fungerer for tilfeller der 
akselerasjonen ikke er en funksjon av hastigheten. 
Metoden er gitt som

\begin{enumerate}
\item Regn ut: \begin{align*}
\vec{v}\left(t + \tfrac12\,\Delta t\right) = \vec{v}(t) + \tfrac12\,\vec{a}(t)\,\Delta t\ 
\end{align*}


\item Finn så: \begin{align*} \vec{r}(t + \Delta t) = \vec{r}(t) + \vec{v}\left(t + \tfrac12\,\Delta t\right)\, \Delta t \end{align*}


\item Regn ut: \begin{align*} \vec{a}(t + \Delta t) 
\end{align*} fra \eqref{eq:a_i} med posisjonen $ \vec{r}(t + \Delta t) $


\item Til slutt: \begin{align*} \vec{v}(t + \Delta t) = \vec{v}\left(t + \tfrac12\,\Delta t\right) + \tfrac12\,\vec{a}(t + \Delta t)\Delta t \end{align*}
\end{enumerate}

\subsection{Initialisering av systemet}
Vi kan selv velge fritt starttilstanden til systemet vårt. Vi velger å
begynne med $N$ objekter fordelt uniformt innenfor en sfære med
radius $R_0$. Objektene gir vi en tilfeldig masse ved å la massene
følge en Gaussisk fordeling med snittverdi $10M_\odot$ og standardavik
på $M_\odot$. Her er $M_\odot$ solmassen. Vi lar alle starte i ro. 

Av disse startbetingelesene er det en del som trenger noe ekstra
oppmerksomhet\footnote{Det som følger er i stor grad en oversettelse
  av et skriv laget av H. T. Ihle.}. Det er ikke helt fullstendig trivielt å lage uniformt
fordelte koordinater innenfor en sfære. Problemet er at hvis vi lar
objektene være uniformt fordelt i $r$, så vil vi ende med en mye
større tetthet rundt midten av sfæren. Og hvis vi fordeler objektene
uniformt i $\theta$ vil tettheten blir mye større rundt polene. 

Vi løser dette ved å bruke at volumelementet skal være det samme i
alle koordinatsystemer. Vi innfører koordinatene $u, v, w \in [0,1]$
og kobler disse koordinatene mot (i rekkefølge) $r,\theta$ og
$\phi$. Vi kan da skrive 
\begin{align*}
  r^2\sin\theta dr d\theta d\phi = (abc)dudvdw
\end{align*}
der $A=abc$ er en konstant. Separerer vi likningen for hvert par av
koordinater får vi likningene 
\begin{align*}
  r^2dr = adu,\ \ \sin\theta d\theta = bdv,\ \ d\phi = cdw
\end{align*}
Begynner vi med den siste og enkleste får vi 
\begin{align}
  d\phi = cdw\Rightarrow \phi = 2\pi w
\end{align}
der vi har brukt at $\phi=2\pi$ må svare til $w=1$. Samme
fremgangsmåte for $r$ og $\theta$ gir
\begin{align}
  r &= R_0 \sqrt[3]{u}\\
  \theta &= \arccos(1-2v).
\end{align}


\section{Implementering og testing}
Hovedprogrammet er skrevet i C++, mens vi har gjort dataanalysen i Python.
Alle programmer er tilgjengelig på Github~\cite{github-repo}. 

\subsection{Klassesystem}
Vi har to klasser. Én objektklasse 'body' som inneholder med posisjon, fart 
og masse for et gitt legeme. Den andre klassen er 'Universe' og initialiseres
med et gitt antall 'body'-objekter. Denne klassen inneholder mange metoder,
som f.eks. 'Universe::energy' for å regne ut energien til systemet, og 
'Universe::solve\_RK4' eller 'Universe::solve\_Verlet' for å løse systemet
for en gitt tid.
\subsection{solver}

\subsection{Første test av programmet}
Det er ikke alltid lett å sjekke om en løsning gir mening. Vi begynner med
å animere systemet \footnote{Tilgjengelig på \cite{github-repo} under navnet
animate\_pos.py}, og ser fort at det skjedde noe rart når massene kom veldig
nærme hverandre. Som en korreksjon til dette la vi til et feilledd i kraften

\begin{align}
F_{mod} = -\frac{GM_1M_2}{r^2 + \epsilon}.
\end{align}

Der $\epsilon$ gjør at $F_{mod}$ ikke går i lufta når $r^2 \rightarrow \infty$. 
Dette kan vi tenke på som at legemene har en endelig størrelse. 
Vi setter $\epsilon = 10^{-3}$. 

\subsection{Energibevaring}
Selv om animasjoner alltid er flott, tenker vi det kan være lurt å ha en mer
'matematisk' test på systemet vårt. Dette gjør oss også mer egnet til
å gjøre en kvalitativ vurdering av hvilken av de løsningnsmetodene som er best
I et slikt ideelt system med bare 
gravitasjon(konservativ kraft) er det naturlig å se på energibevaring. Vi får
energien

\begin{align}
E_{p} = - \sum_{i = 1}^{N} \sum_{j = i+1}^{N} \frac{GM_jM_i}{{||\vec{r_i} - \vec{r_j}||}} \\
E_{k} = \sum_{i} \frac{1}{2}M_i|\vec{v_i}|^2 \\
E_{tot} = E_{p} + E_{k}
\end{align}

I tabell \ref{tab:RKvsVV}


\begin{table*}[!ht]
\centering
\caption{En tabell som sammenligner relativ energiendring for de to metodene
RungeKutta4 og VelocityVerlet. Energiendringen regnes ut fra systemet starter
i ro ved $t_0 = 0$ til $T$ for to forskjellige steglengder
$h$.  Kjøretiden, $T$, måles i enhet $\tau_{crunch}$. Ideelt sett vil vi ha $\Delta E = 0$.}
\label{tab:RKvsVV}
\vspace{0.5cm}
\begin{tabular}{ccccc}
Kjøreparametre $(T, log(h))$ & $(0.79,-3)$ & $(0.79,-4)$ & $(2.5,-3)$ & $(2.5,-4)$ \\
\hline 
Energiendring og tidsforbruk,$(E,\Delta t)$ RK4 & $(2.4E-01, 006.6)$ & $(2.8E-03, 046.7)$ & $(6.6E-01, 011.1)$ & $(2.2E-02, 120.8)$ \\
Energiendring og tidsforbruk,$(E,\Delta t)$ VV & $(4.9E-01, 001.9)$ & $(2.9E-03, 027.5)$ & $(9.1E-01, 005.7)$ & $(5.1E-03, 058.6)$ \\
\hline
\end{tabular}
\end{table*}




\printbibliography
\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
