\documentclass[11pt, twocolumn]{article}
\usepackage{../../latex/preamble}

\newcommand{\abs}[1]{|#1|}
\begin{document}
  % make title page
\begin{titlepage}
  \newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
  \center
  \textsc{\LARGE Universitetet i Oslo}\\[1.5cm] % Name of your university/college
  \textsc{\Large }\\[0.5cm] % Major heading such as course name
  \textsc{\large FYS3150}\\[0.5cm] % Minor heading such as course title
  \HRule \\[0.4cm]
  { \huge \bfseries N-body simulering}\\[0.4cm]
  \HRule \\[1.5cm]
  \Large \emph{Skrevet av:}\\
  Lyder \textsc{Rumohr Blingsmo} (k.nr. 2) og Bendik \textsc{Samseth} (k.nr. 27)\\[3cm]
  {\large \today}\\[3cm]
  \vfill
\end{titlepage}
\twocolumn[
\begin{@twocolumnfalse}
\tableofcontents
\vspace{\baselineskip}
\begin{abstract}
I denne rapporten utvikler vi en N-body modell. Det vil si et system av
$N$ masser som vekselvirker kun ved gravitasjon. Spesielt studerer vi kollaps
av et slik system når alle partiklene begynner i ro. Vi sammenligner 
stabiliteten til to forskjellige løsningsmetoder, RungeKutta4 og VelocityVerlet,
ved å kikke på energibevaring i systemet. 
Alt materiale som har blitt referert er tilgjengelig
 på Github~\cite{github-repo}. 

\end{abstract}
\vspace{\baselineskip}
\end{@twocolumnfalse}
]

\section{Innledning}
Vi ser på en åpen galaksehop med $N$ partikler. I vårt system antar vi at 
gravitasjon er den eneste kraften som virker

\begin{align}
 F = -\frac{GM_1M_2}{r^2}.\
\end{align}

Her er $G$ gravitasjonskonstanten, $M$ er massene og $r$ er avstanden mellom dem. 
Denne antagelsen er god under forutsetningen av $r$ er relativt stor. Vi bruker
Newtons andre lov, og får differensialligningene 

\begin{align} \label{eq:a_i}
a_i = \sum_{j \neq i} \frac{GM_j}{{|\vec{r_i} - \vec{r_j}|}^2} ,  i = 1,2, \cdots N 
\end{align}

Der $a_i$ er akselerasjonen til masse $i$. Dette er en ordinære differensialligning, og
vi anvender RungeKutta4 og Velocity-Verlet.

\subsection{Kort om RungeKutta4~\small{\cite{RK4}}}
Gitt en funksjon på formen 
\begin{align*}
\dot{y} = f(t, y), \quad y(t_0) = y_0
\end{align*}

I vårt tilfelle \eqref{eq:a_i} med 

\begin{align*}
\dot{v_i} = a_i 
\end{align*}
med initialbetingelsene
\begin{align*}
r_i(t_0) = r_{i,0},\ \  v_i(t_0) = 0
\end{align*}
Velg en steglengde $h>0$ og definer 

\begin{align*}
y_{n+1} &= y_n + \tfrac{h}{6}\left(k_1 + 2k_2 + 2k_3 + k_4 \right)\\
t_{n+1} &= t_n + h \\
\end{align*}
der vi har
\begin{align*}
k_1 &= f(t_n, y_n), \\
k_2 &= f(t_n + \tfrac{h}{2}, y_n + \tfrac{h}{2} k_1), \\
k_3 &= f(t_n + \tfrac{h}{2}, y_n + \tfrac{h}{2} k_2), \\
k_4 &= f(t_n + h, y_n + hk_3).
\end{align*}

Vi gjentar så metoden en gang til for 

\begin{align*}
\dot{x_i} = v_i
\end{align*}

\subsection{Kort Velocity-Verlet~\small{\cite{Velocity-Verlet}}}
Vi anvender også Velocity-Verlet på \eqref{eq:a_i}. Den fungerer for tilfeller der 
akselerasjonen ikke er en funksjon av hastigheten. 
Metoden er gitt som

\begin{enumerate}
\item Regn ut: \begin{align*}
\vec{v}\left(t + \tfrac12\,\Delta t\right) = \vec{v}(t) + \tfrac12\,\vec{a}(t)\,\Delta t\ 
\end{align*}


\item Finn så: \begin{align*} \vec{r}(t + \Delta t) = \vec{r}(t) + \vec{v}\left(t + \tfrac12\,\Delta t\right)\, \Delta t \end{align*}


\item Regn ut: \begin{align*} \vec{a}(t + \Delta t) 
\end{align*} fra \eqref{eq:a_i} med posisjonen $ \vec{r}(t + \Delta t) $


\item Til slutt: \begin{align*} \vec{v}(t + \Delta t) = \vec{v}\left(t + \tfrac12\,\Delta t\right) + \tfrac12\,\vec{a}(t + \Delta t)\Delta t \end{align*}
\end{enumerate}

\subsection{Initialisering av systemet}
Vi kan selv velge fritt starttilstanden til systemet vårt. Vi velger å
begynne med $N$ objekter fordelt uniformt innenfor en sfære med
radius $R_0$. Objektene gir vi en tilfeldig masse ved å la massene
følge en Gaussisk fordeling med snittverdi $10M_\odot$ og standardavik
på $M_\odot$. Her er $M_\odot$ solmassen. Vi lar alle starte i ro. 

Av disse startbetingelesene er det en del som trenger noe ekstra
oppmerksomhet\footnote{Det som følger er i stor grad en oversettelse
  av et skriv laget av H. T. Ihle.}. Det er ikke helt fullstendig trivielt å lage uniformt
fordelte koordinater innenfor en sfære. Problemet er at hvis vi lar
objektene være uniformt fordelt i $r$, så vil vi ende med en mye
større tetthet rundt midten av sfæren. Og hvis vi fordeler objektene
uniformt i $\theta$ vil tettheten blir mye større rundt polene. 

Vi løser dette ved å bruke at volumelementet skal være det samme i
alle koordinatsystemer. Vi innfører koordinatene $u, v, w \in [0,1]$
og kobler disse koordinatene mot (i rekkefølge) $r,\theta$ og
$\phi$. Vi kan da skrive 
\begin{align*}
  r^2\sin\theta dr d\theta d\phi = (abc)dudvdw
\end{align*}
der $A=abc$ er en konstant. Separerer vi likningen for hvert par av
koordinater får vi likningene 
\begin{align*}
  r^2dr = adu,\ \ \sin\theta d\theta = bdv,\ \ d\phi = cdw
\end{align*}
Begynner vi med den siste og enkleste får vi 
\begin{align}
  d\phi = cdw\Rightarrow \phi = 2\pi w
\end{align}
der vi har brukt at $\phi=2\pi$ må svare til $w=1$. Samme
fremgangsmåte for $r$ og $\theta$ gir
\begin{align}
  r &= R_0 \sqrt[3]{u}\\
  \theta &= \arccos(1-2v).
\end{align}


\section{Implementering og testing}
Hovedprogrammet er skrevet i C++, mens vi har gjort dataanalysen i Python.
Alle programmer er tilgjengelig på Github~\cite{github-repo}. 

\subsection{Klassesystem}
Vi har to klasser. Én objektklasse 'Body' som inneholder med posisjon, fart 
og masse for et gitt legeme. Den andre klassen er 'Universe' og initialiseres
med et gitt antall 'Body'-objekter. Denne klassen inneholder mange metoder,
som f.eks. \texttt{Universe::energy} for å regne ut energien til systemet, og 
\texttt{Universe::solve\_RK4} eller \texttt{Universe::solve\_Verlet} for å løse systemet
for en gitt tid.

\subsection{Solver}
Selve implementasjonen av løsningsmetodene er noe innviklet. Dette
kommer av at vi har et system av to ordinære differensialligninger,
hver med tre koordinater. Altså har vi egentlig seks diff.likninger
som skal løses samtidig. Metodene som vi har skissert tidligere endrer
ikke form, men det kan bli litt vanskelig å holde styr på alt
sammen. Derfor skal vi gå nokså grundig i gjennom hvordan disse
metodene er implementert. Dvs., vi gjør dette for Runge-Kutta;
Velocity-Verlet er løst på en analog måte. RK4 er implementert i
\texttt{Universe} slik som vist i vedlegg \ref{lst:solver-RK4}. 

Vi begynner med å definere flere $N\times 7$ matriser. Dette svarer til
en rad per legeme, der kolonnene er de tilhørende verdiene av (i rekkefølge) $x,y,z,v_x,v_y,v_z$
og $M$. 


\subsection{Første test av programmet}
Det er ikke alltid lett å sjekke om en løsning gir mening. Vi begynner med
å animere systemet \footnote{Tilgjengelig på \cite{github-repo} under navnet
animate\_pos.py}, og ser fort at det skjedde noe rart når massene kom veldig
nærme hverandre. Som en korreksjon til dette la vi til et feilledd i kraften

\begin{align}
F_{mod} = -\frac{GM_1M_2}{r^2 + \epsilon}.
\end{align}

Der $\epsilon$ gjør at $F_{mod}$ ikke går i lufta når $r^2 \rightarrow \infty$.
Vi setter $\epsilon = 10^{-3}$. 

\subsection{Energibevaring}
Selv om animasjoner alltid er flott, tenker vi det kan være lurt å ha en mer
'matematisk' test på systemet vårt. Dette gjør oss også mer egnet til
å gjøre en kvalitativ vurdering av hvilken av de løsningnsmetodene som er best
I et slikt ideelt system med bare 
gravitasjon(konservativ kraft) er det naturlig å se på energibevaring. Vi får
energien

\begin{align}
E_{p} = - \sum_{i = 1}^{N} \sum_{j = i+1}^{N} \frac{GM_jM_i}{{||\vec{r_i} - \vec{r_j}||}} \\
E_{k} = \sum_{i} \frac{1}{2}M_i|\vec{v_i}|^2 \\
E_{tot} = E_{p} + E_{k}
\end{align}

I tabell ???

\printbibliography
\onecolumn
\section{Vedlegg}
\begin{itemize}
  \item[]\lstinputlisting[language=c++, caption={C++ metode som bruker Runge-Kutta 4 til å tidsutvikle
  systemet.}, label={lst:solver-RK4}]{solversnippet.txt}
\end{itemize}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
